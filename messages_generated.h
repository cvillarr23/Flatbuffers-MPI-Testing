// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGES_MESSAGETEST_H_
#define FLATBUFFERS_GENERATED_MESSAGES_MESSAGETEST_H_

#include "flatbuffers/flatbuffers.h"

namespace MessageTest {

struct Messages;

struct Message;

struct Vector;

struct VehiclePosition;

struct Update;

enum Type {
  Type_NONE = 0,
  Type_Vector = 1,
  Type_VehiclePosition = 2,
  Type_Update = 3,
  Type_MIN = Type_NONE,
  Type_MAX = Type_Update
};

inline const Type (&EnumValuesType())[4] {
  static const Type values[] = {
    Type_NONE,
    Type_Vector,
    Type_VehiclePosition,
    Type_Update
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[] = {
    "NONE",
    "Vector",
    "VehiclePosition",
    "Update",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_Update) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<Vector> {
  static const Type enum_value = Type_Vector;
};

template<> struct TypeTraits<VehiclePosition> {
  static const Type enum_value = Type_VehiclePosition;
};

template<> struct TypeTraits<Update> {
  static const Type enum_value = Type_Update;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Messages FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGES = 4,
    VT_TIME = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Message>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Message>> *>(VT_MESSAGES);
  }
  const Message *time() const {
    return GetPointer<const Message *>(VT_TIME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.VerifyTable(time()) &&
           verifier.EndTable();
  }
};

struct MessagesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Message>>> messages) {
    fbb_.AddOffset(Messages::VT_MESSAGES, messages);
  }
  void add_time(flatbuffers::Offset<Message> time) {
    fbb_.AddOffset(Messages::VT_TIME, time);
  }
  explicit MessagesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessagesBuilder &operator=(const MessagesBuilder &);
  flatbuffers::Offset<Messages> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Messages>(end);
    return o;
  }
};

inline flatbuffers::Offset<Messages> CreateMessages(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Message>>> messages = 0,
    flatbuffers::Offset<Message> time = 0) {
  MessagesBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_messages(messages);
  return builder_.Finish();
}

inline flatbuffers::Offset<Messages> CreateMessagesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Message>> *messages = nullptr,
    flatbuffers::Offset<Message> time = 0) {
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<Message>>(*messages) : 0;
  return MessageTest::CreateMessages(
      _fbb,
      messages__,
      time);
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6,
    VT_ID = 8
  };
  Type message_type() const {
    return static_cast<Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const Vector *message_as_Vector() const {
    return message_type() == Type_Vector ? static_cast<const Vector *>(message()) : nullptr;
  }
  const VehiclePosition *message_as_VehiclePosition() const {
    return message_type() == Type_VehiclePosition ? static_cast<const VehiclePosition *>(message()) : nullptr;
  }
  const Update *message_as_Update() const {
    return message_type() == Type_Update ? static_cast<const Update *>(message()) : nullptr;
  }
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

template<> inline const Vector *Message::message_as<Vector>() const {
  return message_as_Vector();
}

template<> inline const VehiclePosition *Message::message_as<VehiclePosition>() const {
  return message_as_VehiclePosition();
}

template<> inline const Update *Message::message_as<Update>() const {
  return message_as_Update();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(Type message_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Message::VT_MESSAGE, message);
  }
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Message::VT_ID, id);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type message_type = Type_NONE,
    flatbuffers::Offset<void> message = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type message_type = Type_NONE,
    flatbuffers::Offset<void> message = 0,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return MessageTest::CreateMessage(
      _fbb,
      message_type,
      message,
      id__);
}

struct Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Vector::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector::VT_Z, z, 0.0);
  }
  explicit VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VectorBuilder &operator=(const VectorBuilder &);
  flatbuffers::Offset<Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector> CreateVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  VectorBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct VehiclePosition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RANK = 4,
    VT_POSITION = 6
  };
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  const Vector *position() const {
    return GetPointer<const Vector *>(VT_POSITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           verifier.EndTable();
  }
};

struct VehiclePositionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(VehiclePosition::VT_RANK, rank, 0);
  }
  void add_position(flatbuffers::Offset<Vector> position) {
    fbb_.AddOffset(VehiclePosition::VT_POSITION, position);
  }
  explicit VehiclePositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VehiclePositionBuilder &operator=(const VehiclePositionBuilder &);
  flatbuffers::Offset<VehiclePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VehiclePosition>(end);
    return o;
  }
};

inline flatbuffers::Offset<VehiclePosition> CreateVehiclePosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rank = 0,
    flatbuffers::Offset<Vector> position = 0) {
  VehiclePositionBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_rank(rank);
  return builder_.Finish();
}

struct Update FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RANK = 4,
    VT_POSUPDATE = 6
  };
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  const VehiclePosition *posUpdate() const {
    return GetPointer<const VehiclePosition *>(VT_POSUPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyOffset(verifier, VT_POSUPDATE) &&
           verifier.VerifyTable(posUpdate()) &&
           verifier.EndTable();
  }
};

struct UpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(Update::VT_RANK, rank, 0);
  }
  void add_posUpdate(flatbuffers::Offset<VehiclePosition> posUpdate) {
    fbb_.AddOffset(Update::VT_POSUPDATE, posUpdate);
  }
  explicit UpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateBuilder &operator=(const UpdateBuilder &);
  flatbuffers::Offset<Update> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Update>(end);
    return o;
  }
};

inline flatbuffers::Offset<Update> CreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rank = 0,
    flatbuffers::Offset<VehiclePosition> posUpdate = 0) {
  UpdateBuilder builder_(_fbb);
  builder_.add_posUpdate(posUpdate);
  builder_.add_rank(rank);
  return builder_.Finish();
}

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Vector: {
      auto ptr = reinterpret_cast<const Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_VehiclePosition: {
      auto ptr = reinterpret_cast<const VehiclePosition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Update: {
      auto ptr = reinterpret_cast<const Update *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace MessageTest

#endif  // FLATBUFFERS_GENERATED_MESSAGES_MESSAGETEST_H_
