// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGES_AGENTFLATBUF_H_
#define FLATBUFFERS_GENERATED_MESSAGES_AGENTFLATBUF_H_

#include "flatbuffers/flatbuffers.h"
#include <iostream>

namespace AgentFlatbuf {

struct State;

struct Orientation;

struct Vector;

struct Quaternion;

enum Type {
  Type_NONE = 0,
  Type_Vector = 1,
  Type_Quaternion = 2,
  Type_Orientation = 3,
  Type_MIN = Type_NONE,
  Type_MAX = Type_Orientation
};

inline const Type (&EnumValuesType())[4] {
  static const Type values[] = {
    Type_NONE,
    Type_Vector,
    Type_Quaternion,
    Type_Orientation
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[] = {
    "NONE",
    "Vector",
    "Quaternion",
    "Orientation",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_Orientation) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<Vector> {
  static const Type enum_value = Type_Vector;
};

template<> struct TypeTraits<Quaternion> {
  static const Type enum_value = Type_Quaternion;
};

template<> struct TypeTraits<Orientation> {
  static const Type enum_value = Type_Orientation;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_CHASSIS = 6,
    VT_WHEEL0 = 8,
    VT_WHEEL1 = 10,
    VT_WHEEL2 = 12,
    VT_WHEEL3 = 14
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const Orientation *chassis() const {
    return GetPointer<const Orientation *>(VT_CHASSIS);
  }
  const Orientation *Wheel0() const {
    return GetPointer<const Orientation *>(VT_WHEEL0);
  }
  const Orientation *Wheel1() const {
    return GetPointer<const Orientation *>(VT_WHEEL1);
  }
  const Orientation *Wheel2() const {
    return GetPointer<const Orientation *>(VT_WHEEL2);
  }
  const Orientation *Wheel3() const {
    return GetPointer<const Orientation *>(VT_WHEEL3);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_CHASSIS) &&
           verifier.VerifyTable(chassis()) &&
           VerifyOffset(verifier, VT_WHEEL0) &&
           verifier.VerifyTable(Wheel0()) &&
           VerifyOffset(verifier, VT_WHEEL1) &&
           verifier.VerifyTable(Wheel1()) &&
           VerifyOffset(verifier, VT_WHEEL2) &&
           verifier.VerifyTable(Wheel2()) &&
           VerifyOffset(verifier, VT_WHEEL3) &&
           verifier.VerifyTable(Wheel3()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_chassis(flatbuffers::Offset<Orientation> chassis) {
    fbb_.AddOffset(State::VT_CHASSIS, chassis);
  }
  void add_Wheel0(flatbuffers::Offset<Orientation> Wheel0) {
    fbb_.AddOffset(State::VT_WHEEL0, Wheel0);
  }
  void add_Wheel1(flatbuffers::Offset<Orientation> Wheel1) {
    fbb_.AddOffset(State::VT_WHEEL1, Wheel1);
  }
  void add_Wheel2(flatbuffers::Offset<Orientation> Wheel2) {
    fbb_.AddOffset(State::VT_WHEEL2, Wheel2);
  }
  void add_Wheel3(flatbuffers::Offset<Orientation> Wheel3) {
    fbb_.AddOffset(State::VT_WHEEL3, Wheel3);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<Orientation> chassis = 0,
    flatbuffers::Offset<Orientation> Wheel0 = 0,
    flatbuffers::Offset<Orientation> Wheel1 = 0,
    flatbuffers::Offset<Orientation> Wheel2 = 0,
    flatbuffers::Offset<Orientation> Wheel3 = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_Wheel3(Wheel3);
  builder_.add_Wheel2(Wheel2);
  builder_.add_Wheel1(Wheel1);
  builder_.add_Wheel0(Wheel0);
  builder_.add_chassis(chassis);
  flatbuffers::Offset<State> ret = builder_.Finish();
  _fbb.Finish(ret);
  uint8_t *buf = _fbb.GetBufferPointer();
  std::cout << _fbb.GetSize() << std::endl;
  return ret;
}

struct Orientation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_ROT = 6
  };
  const Vector *pos() const {
    return GetPointer<const Vector *>(VT_POS);
  }
  const Quaternion *rot() const {
    return GetPointer<const Quaternion *>(VT_ROT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyOffset(verifier, VT_ROT) &&
           verifier.VerifyTable(rot()) &&
           verifier.EndTable();
  }
};

struct OrientationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(flatbuffers::Offset<Vector> pos) {
    fbb_.AddOffset(Orientation::VT_POS, pos);
  }
  void add_rot(flatbuffers::Offset<Quaternion> rot) {
    fbb_.AddOffset(Orientation::VT_ROT, rot);
  }
  explicit OrientationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrientationBuilder &operator=(const OrientationBuilder &);
  flatbuffers::Offset<Orientation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Orientation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Orientation> CreateOrientation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Vector> pos = 0,
    flatbuffers::Offset<Quaternion> rot = 0) {
  OrientationBuilder builder_(_fbb);
  builder_.add_rot(rot);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Vector::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector::VT_Z, z, 0.0);
  }
  explicit VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VectorBuilder &operator=(const VectorBuilder &);
  flatbuffers::Offset<Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector> CreateVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  VectorBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Quaternion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_E0 = 4,
    VT_E1 = 6,
    VT_E2 = 8,
    VT_E3 = 10
  };
  double e0() const {
    return GetField<double>(VT_E0, 0.0);
  }
  double e1() const {
    return GetField<double>(VT_E1, 0.0);
  }
  double e2() const {
    return GetField<double>(VT_E2, 0.0);
  }
  double e3() const {
    return GetField<double>(VT_E3, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_E0) &&
           VerifyField<double>(verifier, VT_E1) &&
           VerifyField<double>(verifier, VT_E2) &&
           VerifyField<double>(verifier, VT_E3) &&
           verifier.EndTable();
  }
};

struct QuaternionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_e0(double e0) {
    fbb_.AddElement<double>(Quaternion::VT_E0, e0, 0.0);
  }
  void add_e1(double e1) {
    fbb_.AddElement<double>(Quaternion::VT_E1, e1, 0.0);
  }
  void add_e2(double e2) {
    fbb_.AddElement<double>(Quaternion::VT_E2, e2, 0.0);
  }
  void add_e3(double e3) {
    fbb_.AddElement<double>(Quaternion::VT_E3, e3, 0.0);
  }
  explicit QuaternionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuaternionBuilder &operator=(const QuaternionBuilder &);
  flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quaternion> CreateQuaternion(
    flatbuffers::FlatBufferBuilder &_fbb,
    double e0 = 0.0,
    double e1 = 0.0,
    double e2 = 0.0,
    double e3 = 0.0) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_e3(e3);
  builder_.add_e2(e2);
  builder_.add_e1(e1);
  builder_.add_e0(e0);
  return builder_.Finish();
}

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Vector: {
      auto ptr = reinterpret_cast<const Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Quaternion: {
      auto ptr = reinterpret_cast<const Quaternion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Orientation: {
      auto ptr = reinterpret_cast<const Orientation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace AgentFlatbuf

#endif  // FLATBUFFERS_GENERATED_MESSAGES_AGENTFLATBUF_H_
